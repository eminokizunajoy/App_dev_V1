generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                       Int                   @id @default(autoincrement()) // ID: 整数型、主キー、自動増分
  email                    String                @unique // メールアドレス: 文字列型、ユニーク
  password                 String // パスワード: 文字列型
  hash                     String? // ハッシュ値: 文字列型、Null許容
  username                 String? // ユーザー名: 文字列型、Null許容
  year                     Int? // 年: 整数型、Null許容
  class                    Int? // クラス: 整数型、Null許容
  birth                    DateTime?             @db.Date // 誕生日: 日付型、Null許容
  resetPasswordToken       String?
  resetPasswordTokenExpiry DateTime?
  level                    Int                   @default(1) //アカウントレベル
  xp                       Int                   @default(0) //総経験値
  icon                     String? //アイコン
  selectedTitleId          Int?                  @unique
  selectedTitle            Title?                @relation(fields: [selectedTitleId], references: [id])
  progresses               UserSubjectProgress[] // このユーザーの科目別進捗のリスト
  unlockedTitles           UserUnlockedTitle[]
  continuouslogin          Int?
  totallogin               Int?                  @default(0)
  lastlogin                DateTime?
  status_Kohaku            Status_Kohaku? //Userに対してStatus_Kohakuは1対1の関係です。
  // UserモデルとUserAnswerモデルが1対多の関係であることを示します。
  answers                  UserAnswer[]
  answer_Algorithm         Answer_Algorithm[]
  answerd_Genre_Table      Answerd_Genre_Table[]
  groups_User              Groups_User[]
  createdProblems          ProgrammingProblem[]  @relation("ProblemCreator")
  createdSelectProblems    SelectProblem[]       @relation("SelectProblemCreator") // SelectProblemとのリレーション
  createdEvents            Create_event[]        @relation("CreatedEvents")
  posts                    Post[]
  createdAssignments       Assignment[]
  loginHistory             LoginHistory[]
  submissions              Submissions[]
  eventParticipants        Event_Participants[] // このユーザーのイベント参加情報（EventParticipantとの対向リレーション）
  eventSubmissions         Event_Submission[] // このユーザーのイベントでの提出（EventSubmissionとの対向リレーション）
  dailyActivitySummaries   DailyActivitySummary[] // 日別アクティビティのサマリ（DailyActivitySummaryとの対向リレーション）
  aiAdviceCredits          Int                   @default(5)
  dailyMissionProgresses UserDailyMissionProgress[]
}

model LoginHistory {
  id         Int      @id @default(autoincrement())
  userId     Int
  loggedInAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id])
}

// グループ内の投稿・お知らせを保存するモデル
model Post {
  id        Int      @id @default(autoincrement())
  content   String   @db.Text
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // --- リレーション ---
  groupId Int // どのグループへの投稿か
  group   Groups @relation(fields: [groupId], references: [id], onDelete: Cascade)

  authorId Int // 誰が投稿したか
  author   User @relation(fields: [authorId], references: [id], onDelete: Cascade)
}

model UserAnswer {
  id         Int      @id @default(autoincrement())
  userId     Int
  answer     String
  isCorrect  Boolean
  answeredAt DateTime @default(now())

  // --- リレーション定義 ---
  user User @relation(fields: [userId], references: [id])

  // --- どの問題タイプへの解答か (いずれか1つのみが設定される) ---
  programingProblem_id     Int?
  basic_A_Info_Question_id Int?
  questions_id             Int?
  selectProblem_id         Int?

  // --- リレーション定義 ---
  programmingProblem    ProgrammingProblem?    @relation(fields: [programingProblem_id], references: [id])
  basic_A_Info_Question Basic_Info_A_Question? @relation(fields: [basic_A_Info_Question_id], references: [id])
  questions             Questions?             @relation(fields: [questions_id], references: [id])
  selectProblem         SelectProblem?         @relation(fields: [selectProblem_id], references: [id])

  // --- パフォーマンス向上のためのインデックス (推奨) ---
  @@index([userId])
  @@index([programingProblem_id])
  @@index([basic_A_Info_Question_id])
  @@index([questions_id])
  @@index([selectProblem_id])
  appliedAmQuestions Applied_am_Question[]
}

//科目テーブル
model Subject {
  id          Int     @id @default(autoincrement())
  name        String  @unique
  description String?

  userProgresses      UserSubjectProgress[] // この科目を学習しているユーザーの進捗リスト
  Questions_Algorithm Questions_Algorithm[]
  SelectProblem       SelectProblem[] // SelectProblemとのリレーション
  problems            Basic_Info_A_Question[]
  appliedAmQuestions Applied_am_Question[]
}

model Language {
  id                  Int                   @id @default(autoincrement())
  name                String                @unique
  Questions_Algorithm Questions_Algorithm[]
  Questions           Questions[]
}

model Answer_Algorithm {
  id         Int     @id @default(autoincrement())
  questionId Int
  userId     Int
  symbol     String
  isCorrect  Boolean
  text       String? @db.Text

  // --- リレーション定義 ---
  user     User                @relation(fields: [userId], references: [id])
  question Questions_Algorithm @relation(fields: [questionId], references: [id])
}

// 問題のカテゴリを管理するマスターテーブル (例: "ストラテジ", "マネジメント")
model Category {
  id   Int    @id @default(autoincrement())
  name String @unique

  // このカテゴリに属する問題のリスト
  problems Basic_Info_A_Question[]
  appliedAmQuestions Applied_am_Question[]
}

model Basic_Info_A_Question {
  id          Int     @id @default(autoincrement())
  title       String // 問題タイトル
  imagePath   String? // 問題画像のパス（Null許容）
  description String  @db.Text // 問題文
  explanation String  @db.Text // 解説

  // 解答群 (例: ["選択肢ア", "選択肢イ", "選択肢ウ", "選択肢エ"])
  answerOptions Json

  // 正解のインデックス (例: 0, 1, 2, 3)
  correctAnswer Int

  sourceYear   String? // 出典の年/区分 (例: "令和5年度")
  sourceNumber String? // 出典の問題番号 (例: "問1")

  // --- リレーションのためのフィールド ---
  difficultyId Int
  subjectId    Int
  assignmentId Int? // 課題は任意なのでオプショナル
  categoryId   Int

  // --- リレーション定義 ---
  difficulty Difficulty  @relation(fields: [difficultyId], references: [id])
  subject    Subject     @relation(fields: [subjectId], references: [id])
  assignment Assignment? @relation(fields: [assignmentId], references: [id])
  category   Category    @relation(fields: [categoryId], references: [id])

  // この問題に対するユーザーの解答履歴
  userAnswers UserAnswer[]
}

model Applied_am_Question {
  id          Int     @id @default(autoincrement())
  title       String // 問題タイトル
  imagePath   String? // 問題画像のパス（Null許容）
  description String  @db.Text // 問題文
  explanation String  @db.Text // 解説

  // 解答群 (例: ["選択肢ア", "選択肢イ", "選択肢ウ", "選択肢エ"])
  answerOptions Json

  // 正解のインデックス (例: 0, 1, 2, 3)
  correctAnswer Int

  sourceYear   String? // 出典の年/区分 (例: "令和5年度")
  sourceNumber String? // 出典の問題番号 (例: "問1")

  // --- リレーションのためのフィールド ---
  difficultyId Int
  subjectId    Int
  assignmentId Int? // 課題は任意なのでオプショナル
  categoryId   Int

  // --- リレーション定義 ---
  difficulty Difficulty  @relation(fields: [difficultyId], references: [id])
  subject    Subject     @relation(fields: [subjectId], references: [id])
  assignment Assignment? @relation(fields: [assignmentId], references: [id])
  category   Category    @relation(fields: [categoryId], references: [id])

  // この問題に対するユーザーの解答履歴
  userAnswers UserAnswer[]
}

model Questions_Algorithm {
  id              Int                @id @default(autoincrement())
  title           String
  description     String?
  explanation     String?
  programLines    String?
  answerOptions   String?
  correctAnswer   String?
  language_id     Int
  initialVariable Json
  logictype       String
  options         Json
  image           String?
  subjectId       Int
  difficultyId    Int
  answers         Answer_Algorithm[]

  // --- リレーション定義 ---
  subject    Subject    @relation(fields: [subjectId], references: [id])
  difficulty Difficulty @relation(fields: [difficultyId], references: [id])
  language   Language   @relation(fields: [language_id], references: [id])
}

model Questions {
  id           Int       @id @default(autoincrement())
  language_id  Int
  genre_id     Int
  title        String
  genreid      Int
  question     String
  answerid     Int
  term         String
  year         DateTime?
  explain      String?
  image        String?
  difficultyId Int

  // --- リレーション定義 ---
  genre       Genre        @relation(fields: [genre_id], references: [id])
  difficulty  Difficulty   @relation(fields: [difficultyId], references: [id])
  language    Language     @relation(fields: [language_id], references: [id])
  userAnswers UserAnswer[]
  Answers     Answers[]
}

/// プログラミング選択問題モデル
model SelectProblem {
  id            Int     @id @default(autoincrement())
  title         String // 問題タイトル
  description   String  @db.Text // 問題文 (Markdown)
  explanation   String? @db.Text // 解説文
  answerOptions Json // 選択肢 (例: ["選択肢A", "選択肢B", ...])
  correctAnswer String // 正解のテキスト

  // --- リレーション ---
  difficultyId Int
  difficulty   Difficulty @relation(fields: [difficultyId], references: [id])

  subjectId Int
  subject   Subject @relation(fields: [subjectId], references: [id])

  createdBy Int?
  creator   User? @relation("SelectProblemCreator", fields: [createdBy], references: [id])

  assignment Assignment? // 課題との関連 (オプショナル)

  // --- タイムスタンプ ---
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userAnswers UserAnswer[]
}

/// プログラミング問題の情報を格納するモデル 
model ProgrammingProblem {
  id Int @id @default(autoincrement())

  // --- 基本情報 ---
  title       String // タイトル
  problemType String @default("コーディング問題") // 問題タイプ
  difficulty  Int    @default(4) // 難易度 (1-10)
  timeLimit   Int    @default(10) // 制限時間 (分)
  category    String @default("プログラミング基礎") // カテゴリ
  topic       String @default("標準入力") // トピック
  tags        String @default("[]") // タグ (JSON文字列)

  // --- 問題内容 ---
  description  String @db.Text // 問題文
  codeTemplate String @default("") @db.Text // コードテンプレート

  // --- 公開設定 ---
  isPublic          Boolean @default(false) // 公開フラグ
  allowTestCaseView Boolean @default(false) // テストケース表示許可
  isDraft           Boolean @default(true) // 下書きフラグ
  isPublished       Boolean @default(false) // 公開済みフラグ

  // --- 作成者情報 ---
  createdBy Int? // 作成者ID
  creator   User? @relation("ProblemCreator", fields: [createdBy], references: [id])

  // --- タイムスタンプ ---
  createdAt DateTime @default(now()) // 作成日時
  updatedAt DateTime @updatedAt // 更新日時

  // --- リレーション ---
  sampleCases SampleCase[] // サンプルケース
  testCases   TestCase[] // テストケース
  files       ProblemFile[] // 添付ファイル
  eventIssues Event_Issue_List[] // イベントで出題される問題とのリレーション（EventIssueモデルの対向フィールド）
  assignment  Assignment? // 課題との関連 (オプショナル) 
  userAnswers UserAnswer[]

  // --- イベント難易度との関連付け (追加) ---
  eventDifficultyId Int?
  eventDifficulty   EventDifficulty? @relation(fields: [eventDifficultyId], references: [id])
}

/// サンプルケースモデル
model SampleCase {
  id             Int    @id @default(autoincrement())
  problemId      Int // 問題ID
  input          String @db.Text // 入力
  expectedOutput String @db.Text // 期待される出力
  description    String @default("") @db.Text // 説明
  order          Int    @default(0) // 表示順序

  // --- リレーション ---
  problem ProgrammingProblem @relation(fields: [problemId], references: [id], onDelete: Cascade)

  // --- インデックス ---
  @@index([problemId])
}

/// テストケースモデル
model TestCase {
  id             Int    @id @default(autoincrement())
  problemId      Int // 問題ID
  name           String @default("ケース1") // テストケース名
  input          String @db.Text // 入力
  expectedOutput String @db.Text // 期待される出力
  description    String @default("") @db.Text // 説明
  order          Int    @default(0) // 表示順序

  // --- リレーション ---
  problem ProgrammingProblem @relation(fields: [problemId], references: [id], onDelete: Cascade)

  // --- インデックス ---
  @@index([problemId])
}

/// 問題添付ファイルモデル
model ProblemFile {
  id           Int      @id @default(autoincrement())
  problemId    Int // 問題ID
  fileName     String // ファイル名
  originalName String // 元のファイル名
  filePath     String // ファイルパス
  fileSize     Int // ファイルサイズ (bytes)
  mimeType     String // MIMEタイプ
  uploadedAt   DateTime @default(now()) // アップロード日時

  // --- リレーション ---
  problem ProgrammingProblem @relation(fields: [problemId], references: [id], onDelete: Cascade)

  // --- インデックス ---
  @@index([problemId])
}

model Genre {
  id        Int         @id @default(autoincrement())
  genre     String      @unique
  Questions Questions[]
}

model Answerd_Genre_Table {
  id                Int @id @default(autoincrement())
  user_id           Int
  Answer_IT         Int
  Answer_Basic_A    Int
  Answer_Basic_B    Int
  Answer_Applied_Am Int
  Answer_Applied_Pm Int
  Answer_Info_Test  Int
  Answer_Python     Int
  Answer_Java       Int

  user User @relation(fields: [user_id], references: [id])
}

model Coding {
  id          Int    @id @default(autoincrement())
  title       String
  question    String
  answer      String
  sample_case String
  testcase_id Int
  image       String
  explain     String
  difficulty  String
  xpid        Int? // イベントのXPでヌル許容対応のため
}

model Test_Case {
  id       Int    @id @default(autoincrement())
  testcase String
}

model Answers {
  id          Int     @id @default(autoincrement())
  question_id Int
  answer      String
  isCorrect   Boolean

  // --- リレーション定義 ---
  question Questions @relation(fields: [question_id], references: [id])
}

model UserSubjectProgress {
  level Int @default(1) //科目ごとのレベル
  xp    Int @default(0) //科目ごとの経験値

  // --- リレーションのためのフィールド ---
  user_id    Int
  subject_id Int

  // --- リレーション定義 ---
  // この進捗がどのユーザーのものかを示す
  user    User    @relation(fields: [user_id], references: [id])
  // この進捗がどの科目のものかを示す
  subject Subject @relation(fields: [subject_id], references: [id])

  // --- 複合主キー ---
  // userIdとsubjectIdの組み合わせがユニークであることを保証する
  // (一人のユーザーが同じ科目で複数の進捗を持つことはないため)
  @@id([user_id, subject_id])
}

// 難易度と獲得XPのマスタテーブル
model Difficulty {
  id                  Int                     @id @default(autoincrement())
  name                String                  @unique // 難易度名 (例: "Easy", "Normal", "Hard")
  xp                  Int // この難易度で得られる経験値
  feed                Int                     @default(0) // この難易度で得られるコハクの満腹度回復量
  Questions_Algorithm Questions_Algorithm[]
  Questions           Questions[]
  SelectProblem       SelectProblem[]
  problems            Basic_Info_A_Question[]
  appliedAmQuestions Applied_am_Question[]
}

model Groups {
  id          Int           @id @default(autoincrement())
  hashedId    String        @unique @default(cuid())
  groupname   String
  body        String        @db.Text
  groups_User Groups_User[]
  assignment  Assignment[]
  posts       Post[]
  invite_code String        @unique
}

model Groups_User {
  user_id   Int
  group_id  Int
  admin_flg Boolean
  // --- リレーション定義 ---
  user      User    @relation(fields: [user_id], references: [id])
  group     Groups  @relation(fields: [group_id], references: [id])

  // user_idとgroup_idの組み合わせを主キーに設定します
  @@id([group_id, user_id])
}

model Submission_Files_Table {
  id           Int      @id @default(autoincrement())
  submissionid Int
  filename     String
  filepath     String
  filesize     Int
  uploaded_at  DateTime @default(now())
}

model Assignment {
  id          Int      @id @default(autoincrement())
  groupid     Int
  title       String
  description String
  due_date    DateTime
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt

  authorId    Int? // 課題作成者のID
  author      User?    @relation(fields: [authorId], references: [id])

  programmingProblemId Int?                @unique // プログラミング問題との関連付け (オプショナル)
  programmingProblem   ProgrammingProblem? @relation(fields: [programmingProblemId], references: [id])

  selectProblemId Int?           @unique // 選択問題との関連付け (オプショナル)
  selectProblem   SelectProblem? @relation(fields: [selectProblemId], references: [id])

  // --- リレーション定義 ---
  group       Groups                  @relation(fields: [groupid], references: [id])
  Submissions Submissions[]
  problems    Basic_Info_A_Question[]
  appliedAmQuestions Applied_am_Question[]
}

model Submissions {
  id            Int      @id @default(autoincrement())
  assignment_id Int
  userid        Int
  description   String
  status        String
  user          User     @relation(fields: [userid], references: [id], onDelete: Cascade)
  codingid      Int
  submitted_at  DateTime @default(now())
  created_at    DateTime @default(now())
  updated_at    DateTime @updatedAt

  assignment Assignment @relation(fields: [assignment_id], references: [id])

  // 課題IDとユーザーIDの組み合わせをユニークにする
  @@unique([assignment_id, userid])
}

model Status_Kohaku {
  id                  Int       @id @default(autoincrement())
  user_id             Int       @unique
  name                String    @default("コハク")
  status              String
  hungerlevel         Int       @default(1000) // 満腹度の初期値
  // 満腹度を最後に更新した日時を記録します
  hungerLastUpdatedAt DateTime?
  birthdate           DateTime@default(now()) @db.Date // 誕生日

  user User @relation(fields: [user_id], references: [id])
}

model Degree {
  id     Int    @id @default(autoincrement())
  degree String @unique
}

model Title {
  id                Int       @id @default(autoincrement())
  name              String    @unique
  description       String
  type              TitleType // 'USER_LEVEL' or 'SUBJECT_LEVEL'
  requiredLevel     Int
  requiredSubjectId Int? // SUBJECT_LEVELの場合のみ

  // --- リレーション ---
  unlockedByUsers UserUnlockedTitle[]
  selectedByUsers User[]
}

model UserUnlockedTitle {
  userId     Int
  titleId    Int
  unlockedAt DateTime @default(now())

  // --- リレーション ---
  user  User  @relation(fields: [userId], references: [id])
  title Title @relation(fields: [titleId], references: [id])

  @@id([userId, titleId])
}

enum TitleType {
  USER_LEVEL
  SUBJECT_LEVEL
}

// イベントを作成するテーブル
model Create_event {
  id           Int       @id @default(autoincrement())
  title        String
  description  String    @db.Text
  inviteCode   String    @unique
  publicStatus Boolean   @default(true)
  startTime    DateTime?
  endTime      DateTime?
  publicTime   DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  // --- リレーション ---
  creatorId         Int
  creator           User     @relation("CreatedEvents", fields: [creatorId], references: [id])
  
  participants      Event_Participants[]
  issues            Event_Issue_List[]

  //イベント開始の判別フラグ
  isStarted Boolean @default(false)
  hasBeenStarted Boolean  @default(false)
}

// イベントの参加者情報を管理するテーブル
model Event_Participants {
  id      Int     @id @default(autoincrement())
  isAdmin Boolean @default(false)

  // 将来的に使用する可能性があるためコメントアウト
  // joinedAt  DateTime @default(now())
  // status    String?

  // --- リレーション ---
  eventId Int
  event   Create_event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  userId Int
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([eventId, userId], name: "eventId_userId_unique")

  //イベント受容の判別フラグ
  hasAccepted Boolean @default(false)

  // イベントでの合計得点
  event_getpoint Int @default(0)
}

// イベントで出題される問題のリスト
model Event_Issue_List {
  id Int @id @default(autoincrement())

  // --- リレーション ---
  eventId Int
  event   Create_event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  // 既存のCodingモデル、もしくはProgrammingProblemモデルと関連付けます
  // ここではProgrammingProblemを想定しています
  problemId Int
  problem   ProgrammingProblem @relation(fields: [problemId], references: [id])

  submissions Event_Submission[]

  @@unique([eventId, problemId], name: "eventId_problemId_unique")
}

// イベント問題への提出情報を管理するテーブル
model Event_Submission {
  id          Int      @id @default(autoincrement())
  status      Boolean
  score       Int
  codeLog     String   @db.Text
  startedAt   DateTime
  submittedAt DateTime @default(now())

  // --- リレーション ---
  userId Int
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  eventIssueId Int
  eventIssue   Event_Issue_List @relation(fields: [eventIssueId], references: [id], onDelete: Cascade)

  @@unique([userId, eventIssueId])
}

// デイリーミッションの種類を定義する列挙型
enum DailyMissionType {
  Answer_the_Question // 問題に答える
  Feed_Them         // コハクに餌を150与える
  Gain_Xp        // 経験値を1000獲得する
}

// デイリーミッションのマスターデータ
model DailyMissionMaster {
  id          Int      @id @default(autoincrement())
  title       String   // 例: "ログインしよう！"
  description String   // 例: "毎日1回のログインで達成"
  
  // ミッションの種別 (ロジックでどの行動をカウントするかを判定するために使用)
  missionType DailyMissionType 
  
  // 達成に必要な回数 (例: ログインなら1, 問題を解くなら3)
  targetCount Int      @default(1)
  
  // 達成時に付与するXP
  xpReward    Int

  // このミッションの進捗を持つユーザーのリスト (中間テーブルへの逆参照)
  progressEntries UserDailyMissionProgress[]
}

// ユーザーごとのデイリーミッション進捗
model UserDailyMissionProgress {
  
  // --- リレーション ---
  userId     Int
  user       User     @relation(fields: [userId], references: [id])
  
  missionId  Int
  mission    DailyMissionMaster @relation(fields: [missionId], references: [id])
  
  // --- 進捗データ ---

  // どの「日」のミッションかを記録 (例: 2025-10-24)
  // これが非常に重要です
  date       DateTime @db.Date 
  
  // 現在の進捗カウント (例: 0, 1, 2...)
  progress   Int      @default(0)
  
  // 達成済みか (報酬を付与済みか)
  isCompleted Boolean  @default(false)

  // 複合主キー: 
  // 「ユーザーID」+「ミッションID」+「日付」の組み合わせをユニークにします
  // (一人のユーザーが、同じ日に同じミッションの進捗を2つ持てないようにする)
  @@id([userId, missionId, date])
}

model DailyActivitySummary {
  id                Int      @id @default(autoincrement())
  userId            Int
  date              DateTime @db.Date // 重要な点: 時間を含まない「日付」のみを保存
  totalXpGained     Int      @default(0) // その日に獲得した総XP
  totalTimeSpentMs  BigInt   @default(0) // その日に学習した総時間 (ミリ秒)
  problemsCompleted Int      @default(0) // その日に完了した問題数

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // 1人のユーザーが同じ日付に複数のレコードを持てないようにするユニーク制約
  @@unique([userId, date])
  // 日付とユーザーIDでの検索を高速化するインデックス
  @@index([userId, date])
}

model EventDifficulty {
  id                   Int    @id @default(autoincrement())
  difficultyName       String @unique
  basePoints           Int
  maxBonusPoints       Int
    maxTotalPoints       Int
    expectedTimeMinutes  Int
    bonusPointsPerMinute Int
  
    // --- ProgrammingProblemとのリレーション (追加) ---
    programmingProblems ProgrammingProblem[]
  }
  